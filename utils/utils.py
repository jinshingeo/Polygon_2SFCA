{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 17,
   "id": "8778b80e-4cea-4c6f-8f26-f486131ecd11",
   "metadata": {},
   "outputs": [],
   "source": [
    "import geopandas as gpd\n",
    "import pandas as pd\n",
    "import osmnx as ox\n",
    "import time\n",
    "import numpy as np\n",
    "from tqdm import tqdm, trange\n",
    "from shapely.geometry import Point, MultiPoint\n",
    "import networkx as nx\n",
    "import matplotlib.pyplot as plt\n",
    "from scipy.stats import pearsonr\n",
    "#from shapely.ops import cascaded_union, unary_union\n",
    "import utils\n",
    "import warnings\n",
    "warnings.filterwarnings(\"ignore\")"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 18,
   "id": "d9403d43-0f09-4c4b-9c30-a6a0b06a1e6e",
   "metadata": {},
   "outputs": [
    {
     "name": "stdout",
     "output_type": "stream",
     "text": [
      "/Users/jin/Downloads/utils\n"
     ]
    }
   ],
   "source": [
    "import os\n",
    "print(os.getcwd())  # 현재 작업 디렉터리 출력"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 19,
   "id": "a02c3053-cf24-48c6-ad01-59548f311478",
   "metadata": {},
   "outputs": [],
   "source": [
    "def nearest_osm(network, gdf):\n",
    "    for idx, row in tqdm(gdf.iterrows(), total=gdf.shape[0]):\n",
    "        if row.geometry.geom_type == 'Point':\n",
    "            nearest_osm = ox.distance.nearest_nodes(network, X=row.geometry.x, Y=row.geometry.y)\n",
    "        elif row.geometry.geom_type =='Polygon' or row.geometry.geom_type =='MultiPolygon':\n",
    "            nearest_osm = ox.distance.nearest_nodes(network, X=row.geometry.centroid.x, Y=row.geometry.centroid.y)\n",
    "        else:\n",
    "            print(row.geometry.geom_type)\n",
    "            continue\n",
    "\n",
    "        gdf.loc[idx, 'nearest_osm'] = nearest_osm\n",
    "    \n",
    "    return gdf"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 20,
   "id": "62c3405e-c6fd-4353-b058-fcc9f6ea85f9",
   "metadata": {},
   "outputs": [],
   "source": [
    "def network_settings_kor(network):\n",
    "    for u, v, data in network.edges(data=True):\n",
    "        if 'maxspeed' in data.keys():\n",
    "            speed_type = type(data['maxspeed'])\n",
    "            if (speed_type==str):\n",
    "                data['maxspeed']=float(data['maxspeed'].split()[0])\n",
    "            else:\n",
    "                data['maxspeed']=float(data['maxspeed'][0].split()[0])\n",
    "\n",
    "        else:\n",
    "            data['maxspeed']= 60\n",
    "\n",
    "\n",
    "            \n",
    "            temp_speed = data['maxspeed'][0] if isinstance(data['maxspeed'], list) else data['maxspeed']# temp_speed가 문자열인 경우만 split 사용\n",
    "            if isinstance(temp_speed, str):\n",
    "                temp_speed = temp_speed.split(' ')[0]   \n",
    "        data['maxspeed_meters'] = data['maxspeed'] * 16.6667  # km/h -> m/s * 0.27778 , km/h -> m/min * 16.6667\n",
    "        data['time']= float(data['length']/data['maxspeed_meters'])\n",
    "\n",
    "\n",
    "    for node, data in network.nodes(data=True):\n",
    "        data['geometry'] = Point(data['x'],data['y'])\n",
    "    \n",
    "    print(\"network set done\")\n",
    "    \n",
    "    return network"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 21,
   "id": "b381146a-6a14-41b9-a124-223f86ea3827",
   "metadata": {},
   "outputs": [],
   "source": [
    "def step1_E2SFCA(weights, supply, supply_attr, demand, demand_attr, network):\n",
    "    \"\"\"\n",
    "    *  convex_hull (X)  *\n",
    "    Input:\n",
    "    - weights (dict): keys: threshold travel time or distance, values: weigths according to the threshold travel times or distance, \n",
    "                      e.g., {5: 1, 10: 0.68, 15: 0.22} or {1000:1, 3000:0.68, 5000:0.22}\n",
    "    - supply (GeoDataFrame): stores locations and attributes of supply \n",
    "    - supply_attr (str): the column of `supply` to be used for the analysis\n",
    "    - demand (GeoDataFrame): stores locations and attributes of demand \n",
    "    - demand_attr (str): the column of `demand` to be used for the analysis\n",
    "    - network (NetworkX MultiDiGraph): Network Dataset obtained from OSMnx\n",
    "\n",
    "    \n",
    "    Output:\n",
    "    - supply_ (GeoDataFrame): \n",
    "      a copy of supply and it stores supply-to-demand ratio of each supply at `ratio` column\n",
    "    \"\"\"\n",
    "    \n",
    "    supply_ = supply.copy(deep=True)\n",
    "    supply_['ratio'] = 0\n",
    "\n",
    "    \n",
    "    for i in tqdm(range(supply_.shape[0])):\n",
    "        total_demand = 0\n",
    "        prev_nodes = set()  # 이전 시간 구간 노드 누적\n",
    "        \n",
    "        # 거리 오름차순으로 정렬 (5 → 10 → 15)\n",
    "        for time, weight in sorted(weights.items(), key=lambda x: x[0]):\n",
    "            # 현재 거리까지의 모든 노드 계산\n",
    "            temp_nodes = nx.single_source_dijkstra_path_length(network, supply_.loc[i, 'nearest_osm'], cutoff=time, weight='time'\n",
    "            ).keys()\n",
    "            \n",
    "            # 현재 구간 노드 = 전체 노드 - 이전 구간 노드\n",
    "            current_nodes = set(temp_nodes) - prev_nodes\n",
    "            \n",
    "            # 수요 계산 및 가중치 적용\n",
    "            demand_sum = demand.loc[demand['nearest_osm'].isin(current_nodes), demand_attr].sum() * weight\n",
    "            \n",
    "            total_demand += demand_sum\n",
    "            \n",
    "            # 다음 구간을 위해 노드 업데이트\n",
    "            prev_nodes.update(temp_nodes)\n",
    "        \n",
    "        # 최종 ratio 계산\n",
    "        supply_value = supply_.loc[i, supply_attr]\n",
    "        step1_ratio = (supply_value / total_demand) * 100000\n",
    "        supply_.loc[i, 'ratio'] = step1_ratio\n",
    "        \n",
    "    return supply_"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 22,
   "id": "ef550c26-4766-4b3e-833c-2513a9a039ac",
   "metadata": {},
   "outputs": [],
   "source": [
    "def step2_E2SFCA(weights, result_step1, demand, network):\n",
    "    demand_ = demand.copy(deep=True)\n",
    "    demand_['access']=0\n",
    "    for z in tqdm(range(demand_.shape[0])):\n",
    "        total_sum = 0\n",
    "        prev_nodes = set()  # 이전 거리 구간 노드 누적\n",
    "        \n",
    "        # 거리 오름차순으로 정렬 (5->10->15)\n",
    "        for time, weight in sorted(weights.items(), key=lambda x: x[0]):\n",
    "            # 현재 거리까지의 모든 노드 계산\n",
    "            temp_nodes = nx.single_source_dijkstra_path_length(network, demand_.loc[z, 'nearest_osm'], cutoff=time, weight='time'\n",
    "            ).keys()\n",
    "            \n",
    "            # 현재 구간 노드 = 전체 노드 - 이전 구간 노드\n",
    "            current_nodes = set(temp_nodes) - prev_nodes\n",
    "            \n",
    "            # 공급 시설 ratio 합산 및 가중치 적용\n",
    "            sum_ratio = supply_.loc[supply_['nearest_osm'].isin(current_nodes), 'ratio'].replace([np.inf, -np.inf], np.nan).dropna().sum() * weight\n",
    "            \n",
    "            total_sum += sum_ratio\n",
    "            \n",
    "            # 다음 구간을 위해 노드 업데이트\n",
    "            prev_nodes.update(temp_nodes)\n",
    "        \n",
    "        # 최종 합계 계산\n",
    "        demand_.loc[z, 'access'] = total_sum\n",
    "\n",
    "        return demand_"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.13.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
